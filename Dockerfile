# Этот шаг использует официальный образ Docker для Go версии 1.19, который будет использован для сборки приложения.
# Образ включает все необходимые инструменты для работы с Go (компилятор, go mod, и т. д.).
FROM golang:1.19

# Устанавливается рабочий каталог /workdir внутри контейнера
WORKDIR /workdir

# копирует все файлы из текущей директории на хосте (где находится Dockerfile) в каталог /workdir внутри контейнера.
# Это включает все исходные файлы Go, конфигурации и другие файлы проекта.
ADD . .

# Выполняется команда go mod download, которая загружает все зависимости, указанные в файлах go.mod и go.sum.
# Это помогает убедиться, что все необходимые библиотеки скачаны до начала компиляции.
RUN go mod download

# В этой строке компилируется приложение.
# CGO_ENABLED=0: Отключает использование C-библиотек в Go, что делает сборку полностью статической и переносимой.
# GOOS=linux: Указывает, что приложение должно быть собрано для операционной системы Linux.
# GOARCH=amd64: Указывает архитектуру процессора (x86_64, 64-бит).
# go build -o bin/app cmd/app/*.go: Компилирует исходники Go, указанные в cmd/app/*.go, в бинарный файл и помещает его в каталог bin/ с именем app.
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o bin/app cmd/app/*.go

# В следующем шаге используется минимальный образ Alpine Linux для финальной сборки.
# Этот образ очень легковесный, что помогает снизить размер итогового Docker-образа.
# Он не включает в себя никаких избыточных инструментов или зависимостей, что делает его подходящим для развертывания готовых приложений.
FROM alpine

# Обновляются пакеты в Alpine (через apk — пакетный менеджер для Alpine).
# Устанавливаются сертификаты для работы с HTTPS (ca-certificates), которые могут быть необходимы, например, для установления защищённых соединений.
# После установки удаляется кеш пакетов с целью уменьшить размер образа (rm -rf /var/cache/apk/*).
RUN apk update && apk add ca-certificates && rm -rf /var/cache/apk/*

# Здесь используется многослойная сборка Docker.
WORKDIR /bin

# Эта строка копирует уже скомпилированный бинарный файл из предыдущего этапа сборки (из стадии FROM golang:1.19)
# COPY --from=0 означает, что файлы копируются из первого шага сборки (индексация стадий начинается с 0).
# Скопированный бинарный файл размещается в директории /bin в финальном контейнере.
COPY --from=0 /workdir/bin/app .

# Контейнер будет слушать порт 8080. Это делается для того, чтобы Docker знал, что контейнер будет использовать этот порт.
# Однако это только инструкция для Docker, она не открывает порт автоматически, но она может быть полезна для взаимодействия с контейнером, например, при создании сети или подключении.
EXPOSE 8080

# Устанавливает команду, которая будет выполняться при запуске контейнера.
# В данном случае это запускает бинарный файл app, который был скопирован в /bin на предыдущем шаге.
# Это означает, что при запуске контейнера будет выполнена команда /bin/app, что и является точкой входа в приложение.
ENTRYPOINT ["app"]